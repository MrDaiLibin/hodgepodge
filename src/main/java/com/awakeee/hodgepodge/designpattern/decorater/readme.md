我们使用继承或组合来扩展对象的行为，但这是在编译时完成的，它适用于类的所有实例。我们无法在运行时添加任何删除任何现有行为的新功能 - 这就是Decorator模式出现时的情况。

假设我们想要实现不同种类的汽车 - 我们可以创建界面Car来定义组装方法然后我们可以拥有一辆Basic汽车，我们还可以将它扩展到跑车和豪华轿车。实现层次结构将如下图所示。

![avatar](https://cdn.journaldev.com/wp-content/uploads/2013/07/inheritance-hierarchy.png)

但是如果我们想要在运行时获得具有跑车和豪华车功能的汽车，那么实施变得复杂，如果我们想要指定哪些功能应该首先添加，它会变得更加复杂。现在想象一下，如果我们有十种不同类型的汽车，使用继承和组合的实现逻辑将无法管理。为了解决这种编程情况，我们在java中应用装饰器模式。